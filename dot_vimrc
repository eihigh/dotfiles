" # キーマップ戦略
" 大前提として、デフォルト挙動を大きく変えすぎないようにする。
" 暗黙の <Leader> として , を利用する。
" 選択モード関連は潰す。
" Ctrl キーは特殊なキーが多いのでなるべく避ける。

" # Vim のバージョンに関わらず欲しい設定

" ## 独自のキーボードレイアウトに合わせるためのマップ

" 移動
nnoremap h h
nnoremap t gj
nnoremap r gk
nnoremap s l
xnoremap h h
xnoremap t gj
xnoremap r gk
xnoremap s l

" ウィンドウ移動
nnoremap <Left>  <C-w>h
nnoremap <Down>  <C-w>j
nnoremap <Up>    <C-w>k
nnoremap <Right> <C-w>l

" ビジュアル
nnoremap e v
nnoremap n V
nnoremap E <C-v>
xnoremap e v
xnoremap n V
xnoremap E <C-v>

" 検索
nnoremap ( N
nnoremap ) n
xnoremap ( N
xnoremap ) n

" IME切り替えで生じるゴミの無視
noremap! <S-F5> <nop>
noremap! <S-F6> <nop>

" ## その他の挙動のカスタマイズ

" 最低限欲しい設定
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8,euc-jp,cp932
set backspace=eol,indent,start

" その他の設定
if isdirectory(expand('~/.cache/vim'))
	set undofile
	set undodir=~/.cache/vim/
endif
set number
set signcolumn=number
set nowrap
set autoread
set autochdir
set tabstop=2
set shiftwidth=2
set hlsearch
set incsearch
set ignorecase
set smartcase
set smartindent
set helplang=ja

" Esc の遅延解消
set ttimeoutlen=0

" yank 範囲
nnoremap Y y$

" 一文字削除でレジスタを消費しない
nnoremap <BS> "_xh
nnoremap x    "_s

" クイックマーク
nnoremap m mM
nnoremap k `Mzz

" ジャンプ後カーソルを中央に
nnoremap g; g;zz
nnoremap g, g,zz

" 保存/終了ショートカット
nnoremap j :w<CR>
nnoremap v :q<CR>

" nohlsearch
nnoremap <silent> <Esc> :<C-u>nohlsearch<CR>

" ウィンドウ分割
nnoremap \| :<C-u>vsplit<CR>

" ウィンドウ入れ替え
" https://gist.github.com/orther/916584
" function! s:swapwindows() abort
" 	if !exists("g:swapsrcwin")
" 		let g:swapsrcwin = winnr()
" 		echo "Marked #" . g:swapsrcwin . " for swap"
" 	else
" 		let l:dstwin = winnr()
" 		let l:dstbuf = bufnr('%')
" 		if g:swapsrcwin == l:dstwin
" 			echo "Unmarked #" . g:swapsrcwin
" 		else
" 			exe g:swapsrcwin . "wincmd w"
" 			let l:srcbuf = bufnr('%')
" 			exe 'hide buf' l:dstbuf
" 			exe l:dstwin . "wincmd w"
" 			exe 'hide buf' l:srcbuf
" 			echo "Windows swapped"
" 		endif
" 
" 		unlet g:swapsrcwin
" 	endif
" endfunction

noremap - :<C-u>call <SID>swapwindows()<CR>

" ターミナルを開く
" <Esc> でターミナルノーマルモードへ遷移
" 代わりに <C-w> 連打で <Esc> 入力
nnoremap <C-t> :<C-u>botright terminal ++rows=20<CR>
tnoremap <C-w><C-w> <Esc>
tnoremap <Esc>      <C-w>N

" z. でカーソル中央固定
set scrolloff=2
noremap <expr> z. &scrolloff == 99 ? ':setlocal scrolloff=2<CR>' : 'zz:setlocal scrolloff=99<CR>'

" 絶対に手放せない abbreviation
abbrev ret return

" NORMAL/INSERT でカーソル形状を変更
if &term =~ 'xterm' || &term == 'win32'
	let &t_SI = "\e[5 q"
	let &t_EI = "\e[2 q"
else
	let &t_SI = "\<Esc>]50;CursorShape=1\x7"
	let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" カーソル行強調表示
set cursorline
augroup vimrc
	autocmd!
	autocmd WinLeave * set nocursorline
	autocmd WinEnter * set cursorline
augroup END

" ステータスラインをシュッとさせる
" utf-8 以外の注意すべきエンコードなら強調する
function! Stl_fenc() abort
	return &fenc == "utf-8" ? "" : "[".&fenc."] "
endfunction
set statusline=\ %m\ %=%{Stl_fenc()}\ %<%f\ 

" # プラグイン

" ## プラグインを利用する環境かチェック

" plug.vim がなければ弾く
if empty(glob('~/.vim/autoload/plug.vim'))
	finish
endif

" バージョンが低ければ弾く
if v:version < 900
	finish
endif

" ## プラグインのインストール

call plug#begin('~/.vim/plugged')

" カラースキーム
Plug 'chriskempson/base16-vim'
Plug 'cocopon/iceberg.vim'

" モーション / オペレータ
Plug 'haya14busa/vim-easymotion'
Plug 'haya14busa/vim-edgemotion'
Plug 'haya14busa/vim-asterisk'

Plug 'andymass/vim-matchup'

Plug 'kana/vim-textobj-user'
Plug 'sgur/vim-textobj-parameter'
Plug 'kana/vim-textobj-indent'

" テキスト編集
Plug 'tyru/caw.vim'

Plug 'machakann/vim-sandwich'

Plug 'cohama/lexima.vim'

" ファイラ / セレクタ
Plug 'ctrlpvim/ctrlp.vim'
Plug 'tacahiroy/ctrlp-funky'

Plug 'cocopon/vaffle.vim'

" パッシブ拡張
Plug 'wellle/context.vim'

Plug 'obcat/vim-sclow'

" 言語
Plug 'prabirshrestha/vim-lsp'
Plug 'mattn/vim-lsp-settings'
Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/asyncomplete-lsp.vim'
Plug 'mattn/ctrlp-lsp'

" 小回り
Plug 'vim-jp/vimdoc-ja'
" Plug 't9md/vim-choosewin'

call plug#end()

" ## プラグインの設定

" カラースキーム
set background=dark
set termguicolors
colorscheme aomi-grayscale

" CtrlP
nmap , :<C-u>CtrlPMRU<CR>
" nmap ,q :<C-u>CtrlPQuickfix<CR>

" com! -bar CtrlPGhq call ctrlp#init(ctrlp#ghq#id())
" nmap <silent> <Space> :<C-u>call ctrlp#init(ctrlp#commands#id())<CR>

" Language Server
" なるべく vim-lsp の README に倣う
let g:lsp_async_completion = 1

let g:lsp_diagnostics_highlights_enabled = 1
let g:lsp_diagnostics_highlights_insert_mode_enabled = 1
let g:lsp_diagnostics_highlights_delay = 100

let g:lsp_diagnostics_signs_enabled = 0

let g:lsp_diagnostics_virtual_text_enabled = 1
let g:lsp_diagnostics_virtual_text_delay = 100
let g:lsp_diagnostics_virtual_text_align = "right"

function! s:on_lsp_buffer_enabled() abort
	setlocal omnifunc=lsp#complete
	if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
	nmap <buffer> ga <plug>(lsp-code-lens)
	nmap <buffer> gA <plug>(lsp-code-action)
	nmap <buffer> gd <plug>(lsp-definition)
	nmap gs :<C-u>CtrlPLspDocumentSymbol<CR>
	nmap gS :<C-u>CtrlPLspWorkspaceSymbol<CR>
	nmap <buffer> gr <plug>(lsp-rename)
	nmap <buffer> gi <plug>(lsp-implementation)
	nmap <buffer> gt <plug>(lsp-type-definition)
	nmap <buffer> [g <plug>(lsp-previous-diagnostic)
	nmap <buffer> ]g <plug>(lsp-next-diagnostic)
	nmap <buffer> K <plug>(lsp-hover)
	" nnoremap <buffer> <expr><c-f> lsp#scroll(+4)
	" nnoremap <buffer> <expr><c-d> lsp#scroll(-4)
	nnoremap gq :<C-u>LspStopServer<CR>
	nmap <buffer> gQ :<C-u>call lsp#disable()<CR>

	" gofmt & goimports
	autocmd! BufWritePre *.go call execute('LspDocumentFormatSync') | call execute('LspCodeActionSync source.organizeImports')
endfunction

augroup lsp_install
	au!
	autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
	autocmd User EasyMotionPromptBegin call lsp#disable_diagnostics_for_buffer()<CR>
	autocmd User EasyMotionPromptEnd call lsp#enable_diagnostics_for_buffer()<CR>
augroup END

" 補完ウィンドウ操作
" up/down では候補を選択しても即座に挿入されずCRで確定する必要があるので、
" C-n/p に置き換えて候補選択と同時に挿入されるようにする。
imap <silent> <expr> <Up>    pumvisible() ? "\<C-p>" : "\<Up>"
imap <silent> <expr> <Down>  pumvisible() ? "\<C-n>" : "\<Down>"
imap <silent> <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
imap <silent> <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
imap <silent> <expr> <CR> pumvisible() ? asyncomplete#close_popup() . "\<CR>" : "\<CR>"

" Easymotion (inline motion only)
let g:EasyMotion_keys = 'aeniyopukhtscrldmbfvqxz'
let g:EasyMotion_smartcase = 1
let g:EasyMotion_do_shade = 0
let g:EasyMotion_startofline = 0
map l <Plug>(easymotion-sl)

" Edgemotion
map T <Plug>(edgemotion-j)
map R <Plug>(edgemotion-k)

" Asterisk
map *  <Plug>(asterisk-z*)
map #  <Plug>(asterisk-z#)
map g* <Plug>(asterisk-gz*)
map g# <Plug>(asterisk-gz#)

" Sandwich
let g:sandwich_no_default_key_mappings = 1
" map gs <Nop>
" nmap gsa <Plug>(sandwich-add)
" xmap gsa <Plug>(sandwich-add)
" omap gsa <Plug>(sandwich-add)
" nmap gsd <Plug>(sandwich-delete-auto)
" xmap gsd <Plug>(sandwich-delete)
" nmap gsr <Plug>(sandwich-replace-auto)
" xmap gsr <Plug>(sandwich-replace)

" Scrollbar
hi link SclowSbar StatusLine

function Eatchar(char)
	let c = nr2char(getchar(0))
	return (c =~ a:char) ? '' : c
endfunction

" Vaffle
let g:vaffle_show_hidden_files = 1
function! s:init_vaffle() abort
	nnoremap <buffer> l <Nop>
	nnoremap <buffer> s <Plug>(vaffle-open-current)
	nnoremap <buffer> t j
	nnoremap <buffer> r k
	nnoremap <buffer> gr <Plug>(vaffle-rename-selected)
endfunction

augroup vimrc_vaffle
	autocmd!
	autocmd FileType vaffle call s:init_vaffle()
augroup END

" Filetype Go
function! s:init_go() abort
	abbrev <buffer> e~ err != nil {<CR>
	abbrev <buffer> a~ append(<C-R>=Eatchar('\s')<CR>
endfunction

augroup vimrc
	autocmd!
	autocmd FileType go call s:init_go()
augroup END
